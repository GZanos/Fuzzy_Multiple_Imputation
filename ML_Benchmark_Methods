# USER CONFIGURATION
# ===================

DATASET_NAME <- "Maternal_Health"  # Change this to any of your dataset names
id_col <- "col_ID"                         # ID column to match train and validate datasets
target_col <- "Target"                     # Target column with missing values

# ==================================================================================================
# Setup and Data Loading
# ==================================================================================================

# --- Packages ---
req <- c("Amelia","missForest","VIM","softImpute","xgboost","Metrics","dplyr","mice")
to_install <- setdiff(req, rownames(installed.packages()))
if(length(to_install)) install.packages(to_install, dependencies = TRUE)

library(Amelia)
library(missForest)
library(VIM)
library(softImpute)
library(xgboost)
library(Metrics)
library(dplyr)
library(mice)

# --- Configuration ---
set.seed(123)

# --- Load data ---
train_file <- paste0(DATASET_NAME, "_train.csv")
validate_file <- paste0(DATASET_NAME, "_validate.csv")

cat("====================================\n")
cat("LOADING DATA\n")
cat("====================================\n")
cat("Dataset:", DATASET_NAME, "\n")
cat("Train file:", train_file, "\n")
cat("Validate file:", validate_file, "\n\n")

# Check if files exist
if(!file.exists(train_file)) stop("Training file not found: ", train_file)
if(!file.exists(validate_file)) stop("Validation file not found: ", validate_file)

train <- read.csv(train_file, stringsAsFactors = FALSE)
validate <- read.csv(validate_file, stringsAsFactors = FALSE)

# Convert target to numeric if needed
if(is.character(train[[target_col]])) {
  train[[target_col]][trimws(train[[target_col]]) == ""] <- NA
}
train[[target_col]] <- suppressWarnings(as.numeric(train[[target_col]]))

# --- Identify missing values ---
missing_idx <- which(is.na(train[[target_col]]))
complete_idx <- which(!is.na(train[[target_col]]))

cat("Total rows in training:", nrow(train), "\n")
cat("Rows with complete target:", length(complete_idx), "\n")
cat("Rows with missing target:", length(missing_idx), "\n\n")

if(length(missing_idx) == 0) {
  stop("No missing values found in target column!")
}

# --- Get ground truth from validation set ---
missing_ids <- train[[id_col]][missing_idx]
ground_truth <- validate %>%
  filter(!!sym(id_col) %in% missing_ids) %>%
  select(all_of(c(id_col, target_col)))

colnames(ground_truth)[2] <- "true_value"

cat("Ground truth values available:", nrow(ground_truth), "\n")
if(nrow(ground_truth) == 0) {
  stop("No matching ground truth values found in validation set!")
}

# --- Prepare features ---
feature_cols <- setdiff(colnames(train), c(id_col, target_col))

# Convert all features to numeric
for (fc in feature_cols) {
  if(!is.numeric(train[[fc]])) {
    train[[fc]] <- suppressWarnings(as.numeric(train[[fc]]))
  }
}

cat("Feature columns:", length(feature_cols), "\n\n")

# ==================================================================================================
# Performance Metrics
# ==================================================================================================

safe_mape <- function(actual, pred) {
  actual <- as.numeric(actual)
  pred <- as.numeric(pred)
  ok <- !is.na(actual) & !is.na(pred) & (actual != 0)
  if(!any(ok)) return(NA_real_)
  mean(abs((pred[ok] - actual[ok]) / actual[ok])) * 100
}

compute_metrics <- function(actual, pred) {
  actual <- as.numeric(actual)
  pred <- as.numeric(pred)
  
  data.frame(
    MSE = mean((pred - actual)^2, na.rm = TRUE),
    MAE = mean(abs(pred - actual), na.rm = TRUE),
    RMSE = sqrt(mean((pred - actual)^2, na.rm = TRUE)),
    MAPE = safe_mape(actual, pred),
    check.names = FALSE
  )
}

# ==================================================================================================
# Imputation Methods
# ==================================================================================================

# ----- 1. Mean Imputation -----
impute_mean <- function(data, target_col, complete_idx, missing_idx) {
  mean_val <- mean(data[complete_idx, target_col], na.rm = TRUE)
  return(rep(mean_val, length(missing_idx)))
}

# ----- 2. Median Imputation -----
impute_median <- function(data, target_col, complete_idx, missing_idx) {
  median_val <- median(data[complete_idx, target_col], na.rm = TRUE)
  return(rep(median_val, length(missing_idx)))
}

# ----- 3. KNN Imputation -----
impute_knn <- function(data, target_col, feature_cols, complete_idx, missing_idx, k = 50) {
  result <- rep(NA, length(missing_idx))
  
  tryCatch({
    for(i in seq_along(missing_idx)) {
      pred_row <- missing_idx[i]
      pred_features <- data[pred_row, feature_cols]
      
      distances <- sapply(complete_idx, function(j) {
        sqrt(sum((data[j, feature_cols] - pred_features)^2, na.rm = TRUE))
      })
      
      nearest <- complete_idx[order(distances)[1:min(k, length(complete_idx))]]
      
      result[i] <- mean(data[nearest, target_col], na.rm = TRUE)
    }
  }, error = function(e) {
    mean_val <- mean(data[complete_idx, target_col], na.rm = TRUE)
    result[is.na(result)] <- mean_val
  })
  
  return(result)
}

# ----- 4. XGBoost -----
impute_xgboost <- function(data, target_col, feature_cols, complete_idx, missing_idx,
                           depth = 1, rounds = 2, eta = 0.00001) {
  result <- rep(NA, length(missing_idx))
  
  tryCatch({
    X_train <- as.matrix(data[complete_idx, feature_cols])
    y_train <- data[complete_idx, target_col]
    
    complete_features <- complete.cases(X_train)
    X_train <- X_train[complete_features, , drop = FALSE]
    y_train <- y_train[complete_features]
    
    if(length(y_train) > 10) {
      dtrain <- xgb.DMatrix(data = X_train, label = y_train)
      
      params <- list(
        objective = "reg:squarederror",
        max_depth = depth,
        eta = eta,
        verbosity = 0
      )
      
      xgb_model <- xgb.train(params, dtrain, nrounds = rounds, verbose = 0)
      
      X_pred <- as.matrix(data[missing_idx, feature_cols])
      dpred <- xgb.DMatrix(data = X_pred)
      result <- predict(xgb_model, dpred)
    }
  }, error = function(e) {
    mean_val <- mean(data[complete_idx, target_col], na.rm = TRUE)
    result[is.na(result)] <- mean_val
  })
  
  return(result)
}

# ----- 5. MICE  -----
impute_mice <- function(data, target_col, feature_cols, complete_idx, missing_idx,
                        method = "pmm", m = 1, maxit = 1) {
  result <- rep(NA, length(missing_idx))
  
  tryCatch({
    cors <- sapply(feature_cols, function(x) {
      abs(cor(data[complete_idx, target_col], data[complete_idx, x], 
              use = "complete.obs", method = "pearson"))
    })
    cors[is.na(cors)] <- 0
    top_features <- names(sort(cors, decreasing = TRUE)[1:min(5, length(feature_cols))])
    
    train_data <- data[complete_idx, c(target_col, top_features)]
    
    mice_train <- mice(train_data, m = 1, method = method, 
                       maxit = 0, printFlag = FALSE, seed = 123)
    
    pred_idx_in_combined <- length(complete_idx) + 1:length(missing_idx)
    combined_data <- rbind(
      data[complete_idx, c(target_col, top_features)],
      data[missing_idx, c(target_col, top_features)]
    )
    
    combined_data[pred_idx_in_combined, target_col] <- NA
    
    mice_result <- mice(combined_data, m = m, method = method, 
                        maxit = maxit, printFlag = FALSE, seed = 123)
    
    completed_list <- complete(mice_result, action = "all")
    for(i in seq_along(missing_idx)) {
      values <- sapply(completed_list, function(df) {
        df[pred_idx_in_combined[i], target_col]
      })
      result[i] <- mean(values, na.rm = TRUE)
    }
  }, error = function(e) {
    mean_val <- mean(data[complete_idx, target_col], na.rm = TRUE)
    result[is.na(result)] <- mean_val
  })
  
  return(result)
}

# ----- 6. MVN  -----
impute_mvn <- function(data, target_col, feature_cols, complete_idx, missing_idx) {
  result <- rep(NA, length(missing_idx))
  
  tryCatch({
    cors <- sapply(feature_cols, function(x) {
      abs(cor(data[complete_idx, target_col], data[complete_idx, x], 
              use = "complete.obs", method = "pearson"))
    })
    cors[is.na(cors)] <- 0
    top_features <- names(sort(cors, decreasing = TRUE)[1:min(3, length(feature_cols))])
    
    pred_idx_in_combined <- length(complete_idx) + 1:length(missing_idx)
    combined_data <- rbind(
      data[complete_idx, c(target_col, top_features)],
      data[missing_idx, c(target_col, top_features)]
    )
    
    combined_data[pred_idx_in_combined, target_col] <- NA
    
    a.out <- amelia(combined_data, m = 1, ridge = 0.05, p2s = 0)
    
    if(!is.null(a.out$imputations) && length(a.out$imputations) > 0) {
      imputed_data <- a.out$imputations[[1]][[target_col]]
      result <- imputed_data[pred_idx_in_combined]
    }
  }, error = function(e) {
    mean_val <- mean(data[complete_idx, target_col], na.rm = TRUE)
    result[is.na(result)] <- mean_val
  })
  
  return(result)
}

# ----- 7. missForest -----
impute_missforest <- function(data, target_col, feature_cols, complete_idx, missing_idx,
                              ntree = 1, maxiter = 1) {
  result <- rep(NA, length(missing_idx))
  
  tryCatch({
    pred_idx_in_combined <- length(complete_idx) + 1:length(missing_idx)
    combined_data <- rbind(
      data[complete_idx, c(target_col, feature_cols)],
      data[missing_idx, c(target_col, feature_cols)]
    )
    
    combined_data[pred_idx_in_combined, target_col] <- NA
    
    mf <- missForest(combined_data, ntree = ntree, maxiter = maxiter, verbose = FALSE)
    
    imputed_data <- mf$ximp[[target_col]]
    result <- imputed_data[pred_idx_in_combined]
  }, error = function(e) {
    mean_val <- mean(data[complete_idx, target_col], na.rm = TRUE)
    result[is.na(result)] <- mean_val
  })
  
  return(result)
}

# ==================================================================================================
# Run All Methods
# ==================================================================================================

cat("====================================\n")
cat("RUNNING IMPUTATION METHODS\n")
cat("====================================\n")
cat("Training on:", length(complete_idx), "complete cases\n")
cat("Imputing:", length(missing_idx), "missing values\n\n")

# Define methods to test
methods <- list(
  list(name = "Mean", func = impute_mean, use_features = FALSE),
  list(name = "Median", func = impute_median, use_features = FALSE),
  list(name = "KNN_k50", func = impute_knn, use_features = TRUE, params = list(k = 50)),
  list(name = "XGBoost", func = impute_xgboost, use_features = TRUE, 
       params = list(depth = 1, rounds = 2, eta = 0.00001)),
  list(name = "MICE_pmm", func = impute_mice, use_features = TRUE, 
       params = list(method = "pmm", m = 1, maxit = 1)),
  list(name = "MVN_Amelia", func = impute_mvn, use_features = TRUE),
  list(name = "missForest", func = impute_missforest, use_features = TRUE, 
       params = list(ntree = 1, maxiter = 1))
)

# Store results
all_imputations <- data.frame(
  row_id = missing_ids
)
colnames(all_imputations)[1] <- id_col

results_summary <- data.frame()

# Run each method
for(method in methods) {
  method_name <- method$name
  cat("Running:", method_name, "...")
  
  start_time <- Sys.time()
  
  tryCatch({
    # Call imputation function
    if(method$use_features) {
      if(!is.null(method$params)) {
        imputed_values <- do.call(method$func, 
                                  c(list(data = train, 
                                         target_col = target_col,
                                         feature_cols = feature_cols,
                                         complete_idx = complete_idx,
                                         missing_idx = missing_idx),
                                    method$params))
      } else {
        imputed_values <- method$func(train, target_col, feature_cols, 
                                      complete_idx, missing_idx)
      }
    } else {
      imputed_values <- method$func(train, target_col, complete_idx, missing_idx)
    }
    
    # Store imputations for missing IDs
    all_imputations[[method_name]] <- imputed_values
    
    # Compare against ground truth validation set
    comparison <- data.frame(
      id = missing_ids,
      imputed = imputed_values
    )
    colnames(comparison)[1] <- id_col
    
    comparison <- comparison %>%
      inner_join(ground_truth, by = id_col)
    
    # Calculate metrics
    if(nrow(comparison) > 0) {
      metrics <- compute_metrics(comparison$true_value, comparison$imputed)
      
      elapsed <- as.numeric(difftime(Sys.time(), start_time, units = "secs"))
      
      results_summary <- rbind(results_summary, data.frame(
        Method = method_name,
        MSE = metrics$MSE,
        MAE = metrics$MAE,
        RMSE = metrics$RMSE,
        MAPE = metrics$MAPE,
        Time_sec = elapsed,
        N_imputed = nrow(comparison)
      ))
      
      cat(" Done (", round(elapsed, 2), "s)\n", sep = "")
    } else {
      cat(" No matching ground truth\n")
    }
    
  }, error = function(e) {
    cat(" FAILED:", e$message, "\n")
  })
}

# ==================================================================================================
# Display Results
# ==================================================================================================

cat("\n====================================\n")
cat("RESULTS\n")
cat("====================================\n\n")

if(nrow(results_summary) > 0) {
  # Sort by RMSE
  results_summary <- results_summary %>%
    arrange(RMSE)
  
  cat("Performance comparison (sorted by RMSE):\n\n")
  print(results_summary, row.names = FALSE, digits = 4)
  
  cat("\n")
  cat("Best method:", results_summary$Method[1], "\n")
  cat("Best RMSE:", round(results_summary$RMSE[1], 4), "\n")
  cat("Best MAE:", round(results_summary$MAE[1], 4), "\n")
  if(!is.na(results_summary$MAPE[1])) {
    cat("Best MAPE:", round(results_summary$MAPE[1], 2), "%\n")
  }
  
  # Save results
  results_file <- paste0(DATASET_NAME, "_imputation_results.csv")
  write.csv(results_summary, results_file, row.names = FALSE)
  cat("\nResults saved to:", results_file, "\n")
  
  # Save all imputations
  imputations_file <- paste0(DATASET_NAME, "_all_imputations.csv")
  write.csv(all_imputations, imputations_file, row.names = FALSE)
  cat("All imputations saved to:", imputations_file, "\n")
  
} else {
  cat("No methods completed successfully!\n")
}

# ==================================================================================================
# Summary
# ==================================================================================================

cat("\n====================================\n")
cat("SUMMARY\n")
cat("====================================\n")
cat("Dataset:", DATASET_NAME, "\n")
cat("Total training rows:", nrow(train), "\n")
cat("Complete cases (used for training):", length(complete_idx), "\n")
cat("Missing values imputed:", length(missing_idx), "\n")
cat("Ground truth available:", nrow(ground_truth), "\n")
cat("Methods tested:", nrow(results_summary), "\n")
cat("\n=== NO DATA LEAKAGE ===\n")
cat("All methods trained ONLY on complete cases\n")
cat("Multivariate methods properly isolated\n")
cat("Results reflect true predictive performance\n")
cat("\nAnalysis complete!\n")
